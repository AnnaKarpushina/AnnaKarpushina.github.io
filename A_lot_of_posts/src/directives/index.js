// Директива focus при монтировании элемента (когда он добавляется в DOM) устанавливает на него фокус, делая его активным для ввода
const focusDirective = {
  mounted(el) {
    el.focus()
  },
  name: 'focus'
}

// Директива intersection при монтировании элемента создает новый экземпляр IntersectionObserver, который отслеживает, 
// когда элемент становится видимым в окне браузера. Колбэк проверяет, если элемент пересекается с видимой областью (isIntersecting), 
// то вызывается функция, переданная в значение директивы intersection (Для постов где пагинация это нужно, чтобы появлялись при скролле)
const intersectionDirective = {
  mounted(el, binding) {
    const options = {
      rootMargin: '0px', //Это свойство определяет "отступ" вокруг корневого элемента, в пределах которого будет отслеживаться видимость целевого элемента
      //Это значение определяет порог видимости элемента, который используется для определения, когда элемент считается видимым. 
      threshold: 1.0 // Значение 1.0 означает, что элемент считается видимым, когда он полностью виден внутри контейнера
    }
    // Это функция обратного вызова, которая будет вызываться каждый раз, когда состояние видимости элемента изменяется
    const callback = (entries, observer) => {
      // Если первый элемент в массиве entries (который представляет собой информацию о видимости элемента) 
      // находится в состоянии isIntersecting (когда элемент становится видимым), то вызывается функция binding.value().
      if (entries[0].isIntersecting) {
        binding.value() //способ вызова функции, переданной в директиву в виде значения
      }
    }
    new IntersectionObserver(callback, options).observe(el)
  },
  name: 'intersection'
}

export default [ focusDirective, intersectionDirective ] 
